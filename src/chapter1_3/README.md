# 容器

## 链表实现

1. 每个操作最坏情况都是常数时间
2. 花费额外的空间和时间操作数据

## 可变大小的数组实现

1. 大多数操作更加高效，少数操作耗费大量时间
2. 节省空间

#### 栈

单向链表+单指针/可变大小的数组实现

#### 队列

单向链表+双指针/循环链表+单指针/可变大小的数组实现

循环链表的指针指向尾元素，尾元素的下一个节点为头元素

#### Deque

双向链表/可变大小数组实现


~ 注：以上实现方式都确保操作为常数的时间复杂度

## 随机容器

1. 出队时将头指针的元素与队中任意一个元素交换位置（需要数组实现）
2. 随机迭代器，在迭代器的构造器中缓存数据，并用shuffle()函数打乱

## 两个栈实现队列

enqueue(): 压进左栈
dequeue(): 若右栈不为空，则出栈返回；否则将左栈的数据全部出栈，最后一个元素返回，其他压进右栈

dequeue()分摊时间复杂度为O(1), 但是个别操作变慢

## 三个栈实现队列

汉诺塔

## 表达式求值：Dijkstra双栈算法

一个栈存放操作符，一个栈存放操作数

## 前移编码

1. 未出现的字符，插入链表表头
2. 出现过的字符，删除链表中该字符，并插入表头

广泛应用与缓存，数据压缩

## 文本缓冲区

一个可以左右移动的光标，可以在光标的位置插入和删除

1. 双向链表+cursor指针实现
2. 双栈实现
    * 一个栈代表光标左侧字符，另一个栈代表光标右侧字符
    * 左/右移操作：左/右栈pop一个字符，右/左栈push这个字符
    * 删除/插入字符操作：对左栈pop/push一个字符

## 禁止迭代器操作容器

用一个计数器计数容器操作，迭代器初始化时保存该计数器的值
在hasNext(), next()函数中检查保存的值和当前值是否一致，
如果不一致则抛出异常