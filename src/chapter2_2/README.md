# 归并排序

1. 将序列分成两半，每一半分别进行归并排序
2. 合并：将序列复制到辅助数组中，再按照顺序添加到序列中

## 时间复杂度 O(Nlg N)

命题：若序列长度为2的幂，则比较的次数为NlgN，访问数组的次数为6NlgN

证明：
    D(N) = 2D(N/2) + N, D(1) = 1  // 每一次合并需要N次比较
    D(N)/N = 2D(N/2)/N + 1
             = 2D(N/4)/(N/2) + 1 + 1
             = ...
             = 1 + 1 + 1 + ...
             = log N
    D(N) = Nlog N

    A(N) = 2A(N/2) + 6N
    同理

## 递归实现

#### 改进1: 小数组用插入排序，可以节省递归调用的开销

#### 改进2: 合并前检查若a[mid] < a[mid+1]，则该序列有序，不需要合并

#### 改进3: a和aux轮流当辅助数组

合并操作将aux数据插入a作为结果<-递归操作将结果保存到a

## 迭代实现

依次对大小1, 2, 4, 8, 16的子序列合并

## 稳定性

不改变相等元素的相对位置的排序算法是稳定的。

归并排序和插入排序是稳定的。
快速排序和选择排序是不稳定的。

## 改进4: 将a的后半部分逆序插入aux，可以减少插入a时的两个边界条件

该改进导致归并算法不稳定。
若前半部分和后半部分的最大值相同，由于前半部分优先，位置靠后的元素回先插入a。

## 基于队列的归并排序

给定N个元素，创建N个队列，每个队列一个元素。创建一个队列的队列，保存这N个队列。
队列出队两个元素，将这两个元素归并，然后入队。

这里用到两个队列的合并，直接对链表操作比较方便。

## 排序算法总结

|排序算法|时间复杂度|稳定性|
|:---: | :---: | :---: |
|选择排序|$O(N^2)$|不稳定|
|插入排序|$O(N^2)$|稳定|
|归并排序|$O(N\log N)$|稳定|
|快速排序||不稳定|

## 链表归并

#### 归并排序

1. 自然归并排序
    1. 从头节点开始寻找一个有序的子序列，mid指向该子序列最后一个节点。
    2. 从mid.next开始寻找下一个有序的子序列，hi序列指向该子序列最后一个节点。
    3. 两个子序列归并。
    4. 直到mid指向链表的最后一个节点排序结束。

2. 归并排序 - 同自底向上的归并排序

#### 乱序算法

同自顶向上的归并排序，随机数作为归并的条件。

## 用归并算法计数逆序对

每次归并选择右侧元素时，逆序对的个数+=左侧剩余元素的个数

