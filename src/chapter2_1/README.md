# 排序算法

## 预备

1. Comparable 接口 - 可比较类型
    实现 CompareTo()函数，返回-1， 0， 1作为比较结果

2. Sort()函数使用less(), exch()函数引用数据，提高代码对多个语言的支持

3. 测试函数isSorted()
    若Sort()函数使用less(), exch()引用数据而不直接存储数据，isSorted()可以用作测试。

## 选择排序

将未排序区域的第一个元素与未排序区域的最小元素交换

##### 时间复杂度

排好序的数组也需要$N$次交换和$\frac 1 2 N^2$次比较
所以，最坏和最好情况的时间复杂度都是 $N^2$

## 插入排序

将未排序区域的第一个元素插入排序区域

##### 逆序对：顺序错误的元素对

> 如 A E E L M O T R X P S
> 逆序对：T-R T-P T-S R-P X-P X-S

##### 部分有序：逆序对个数 $\leq cN $

1. 一个大小为N的有序数组后面跟着大小为10的无序数组
2. 一个大小为N的数组只有10个元素不在最终位置上

猜想：对于**部分有序**数组，插入排序的时间复杂度为N
证明：

    $逆序对个数 = 交换次数$
    $比较次数 = 交换个数 + N - 1 $
    (除了第一个元素，每个元素至少比较一次)

##### 时间复杂度

最坏情况（逆序数组）：$\frac 1 2 N^2$次比较，$\frac 1 2 N^2$次交换（比选择排序更糟）
最好情况（有序数组）：$N$次比较，$0$次交换

##### 改进1: 哨兵

先将最小元素移到第一位，在排序时可以减少j>0的判断条件

##### 改进2

每次比较完不交换，而是将a[j]移动到a[j-1]，这样每次循环可以减少2次的数组访问

## 希尔排序

每次对序列进行h-排序，直到h为1为止

##### h-排序

每间隔h的元素组成一个序列，对该序列进行排序

命题：$h_{n+1}$排序后的序列还是$h_n$有序的。

##### h序列的选择

1. Knuth序列: $h_{n+1} = 3h_n + 1$

2. Sedgewicj序列: 0, 1, 5, 19, 41, 109, 209, 505, 929, 2161, 3905, 8929, 16001, 36289, 64769, 146305, 260609, ...

##### 时间复杂度（开放问题）

已知远小于$O(n^{\frac 3 2})$

